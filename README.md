# Description:

This package provides a way to easily manage arrays of objects using a SQL-like syntax. This way, we can easily do CRUD operations on these arrays, without needing to struggle with `for` or `forEach()` loops. In essence, each object of an array will become like a table row.

In the future, this package will support more functionalities, like selecting rows by "less than" or "greater than" criteria.

# Usage mode:

First, you will need to instantiate the table, by executing:

```{js}
const db = new Table(array);
```

Where the array should be the one you want to convert to a table. Please note this will create a new array of objects, where:

- An ID will be autogenerated (attribute `.id`), and
- The object data will be moved under the `.data` attribute

In any moment, if you want to access the table contents, you may do so by calling the `.select` attribute. The different queries (`whereEquals()`, `unique()`, etc.) only provide a Table object (with the results), so that multiple queries can be chained together.

To add contents, use the following syntax:

```{js}
db.insert(columns, values)
```

The updating function works the same way, and there are two options available:

- `update()`: This will update all the values in the table (or sub-table).
- `updateFirst()`: Once a row has been updated, it will update no more rows.

Where the columns is an array of columns and the values, an array of values that must be in the same order as the columns.

Should you want to slice down a table, depending on any criteria, you should use `whereEquals()` or `whereNotEquals()` like this:

```{js}
db.whereEquals(column, value)
```

You may also call multiple times on `.whereEquals` or `.whereNotEquals`, like so:

```{js}
db.whereEquals(column1, value1).whereNotEquals(column2, value2)...
```

Should you need to get the results of objects in objects (or, as I would call them, "nested columns"), you may do so like this (starting from version 1.0.18):

```{js}
db.whereEquals('column1.column2', 'whatever');
```

For example, this would work in an object like this:

```{js}
[
    {
        column1: {
            column2: "whatever"
        }
    }
]
```

Please note, updating or inserting data in nested columns is not yet supported, but hopefully it will be very soon.

Of course, if, for any reason you need to get an item with a specific ID, by calling `.whereId()`

You can now also get unique values (as of version 1.0.15), by calling the `.unique()` function on the table, like so:

```{js}
db.unique()
```

As usual, if you need to get the actual values, you must call the `.select` attribute.

At last, if you want to delete an entry, you should do as so:

```{js}
db.delete(table)
```

Let's take a look at some more complex usage cases. For example, in the following array:

```{js}
[
    {
        name: 'John',
        age: 43
    },
    {
        name: 'Frank',
        age: 43
    }
]
```

If we wanted to update the people named "John" so that they have an age of 40, we would need to do the following:

```{js}
db.whereEquals('name', 'John').update(['age'], [40]);
```

If we wanted to delete John, we could do as so:

```{js}
db.delete(db.whereEquals('name', 'John'));
```

After doing so, let's say we wanted to see the table data. We can do so by calling `.select`:

```{js}
console.log(db.select)
```

In this case, the result would be the following:

```{js}
[
    {
        id: 1,
        data: {
            name: 'Frank',
            age: 43
        }
    }
]
```
